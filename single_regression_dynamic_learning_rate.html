<!DOCTYPE html>
<html>
<head>
	<title></title>
	<link rel="stylesheet" href="css/chart.css">
</head>
<body>
	<div id="--gbox">
		<div id="--svline"></div>
	</div>
</body>
</html>
<script src="js/jquery-1.12.0.min.js"></script>
<script src="js/d3.min.js"></script>
<script src="js/machine.js"></script>
<script src="js/chart.js"></script>
<script type="text/javascript">
	var mx = Matrix;
	var cal = Calculus;
	var W = [[Math.random()]];
	var b = Math.random();

	var _xData = [82, 112, 148, 161, 79, 135, 152, 208, 171, 82,
					59, 76, 72, 79, 102, 99, 188];
	var _tData = [12000, 17000, 21943, 25200, 10418, 25300, 29500, 42000, 34000, 9904, 
					10000, 12250, 12000, 9990, 11414, 21500, 36300];
	var xData = mx.reshape(_xData, _xData.length, 1);
	var tData = mx.reshape(_tData, _tData.length, 1);


	var lrW = 1; // 1e-5
	var lrb = 0.5; // 

	var drW = 2;
	var drb = 2;

	var dx = 1e-4;

	var f = (x, dx) => { // type 체크할때 json 방식의 checker 를 넣을것.
		if((typeof W) === (typeof x)) 		return lossFunc(dx, b, xData, tData);
		else if((typeof b) === (typeof x))	return lossFunc(W, dx, xData, tData);
	};

	var EW = cal.numericalDerivative(f, W);
	var Eb = cal.numericalDerivative(f, b);


	var chart = new svLinearChart();
	drawChart();

	var cnt = 0;

	var checkW = W, checkb = b;

	console.log("init W: " + W + ", b: " + b + ", EW: " + EW + ", Eb: " + Eb);
	var interval = setInterval(function() { 
		var tmpW = mx.sub(W, mx.mul(lrW, cal.numericalDerivative(f, W)));
		var tmpEW = cal.numericalDerivative(f, tmpW);
		var wFlag = false;
		if(EW > 0) {
			if((tmpEW < 0)&&(EW > tmpEW)&&(Math.abs(EW) < Math.abs(tmpEW))) {
				lrW /= drW;
			} else { 
				wFlag = true; //W = tmpW;
				
			}
		} else {
			if((tmpEW > 0)&&(EW < tmpEW)&&(Math.abs(EW) < Math.abs(tmpEW))) {
				lrW /= drW;
			} else {
				wFlag = true; //W = tmpW;
			}
		}

		var tmpb = b - lrb * cal.numericalDerivative(f, b);
		var tmpEb = cal.numericalDerivative(f, tmpb);
		var bFlag = false;
		
		if(Eb > 0) {
			if((tmpEb < 0)&&(Eb > tmpEb)&&(Math.abs(Eb) < Math.abs(tmpEb))) {
				lrb /= drb;
			} else {
				bFlag = true; //b = tmpb;
			}
		} else {
			if((tmpEb > 0)&&(Eb < tmpEb)&&(Math.abs(Eb) < Math.abs(tmpEb))) {
				lrb /= drb;
			} else {
				bFlag = true; //b = tmpb;
			}
		}

		if(wFlag) {
			W = tmpW;
		} else {
			W = mx.sub(W, 1e-4);
		}
		if(bFlag) {
			b = tmpb;
		} else {
			b -= 1e-4;
		}

		cnt++;
		if(cnt % 1 == 0) {
			console.log("cnt="+cnt+", W: " + W + ", b: " + b + ", EW: " + tmpEW + ", Eb: " + tmpEb);
			chart.redraw({
				W: W,
				b: b
			});

			if(mx.array_equal(checkW, W) && checkb == b) {
				console.log("called cnt: " + cnt);
				clearInterval(interval);
			} else {
				checkW = W; 
				checkb = b;
			}
		}
	}, 100)

function lossFunc(W, b, x, t) {
	var y = Machine.getYMatrix(x, W, b); // y = Wx + b;
	return mx.sum(mx.pow(mx.sub(t, y), 2)) / mx.size(x);
}

function drawChart() {
	var options = {};
	options.select = "#--svline";
	options.parent = "#--gbox";
	options.width = 500;
	options.ratio = 0.6;

	options.margin = {top: 40, right: 30, bottom: 40, left: 30};
	options.xaxis = true;

	options.xData = xData;
	options.yData = tData;

	options.W = W;
	options.b = b;

	
	chart.init(options);
	chart.draw();

}
</script>